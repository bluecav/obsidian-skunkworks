/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NoteToolbarPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/Settings/NoteToolbarSettingTab.ts
var import_obsidian8 = require("obsidian");

// src/Utils/Utils.ts
var DEBUG = false;
function arraymove(arr, fromIndex, toIndex) {
  if (toIndex < 0 || toIndex === arr.length) {
    return;
  }
  const element = arr[fromIndex];
  arr[fromIndex] = arr[toIndex];
  arr[toIndex] = element;
}
function calcItemVisPlatform(hideOnDesktop, hideOnMobile) {
  if (!hideOnDesktop && !hideOnMobile) {
    return "all";
  } else if (hideOnDesktop && hideOnMobile) {
    return "none";
  } else if (hideOnMobile) {
    return "desktop";
  } else if (hideOnDesktop) {
    return "mobile";
  } else {
    return "all";
  }
}
function calcItemVisToggles(platform) {
  switch (platform) {
    case "all":
      return [false, false];
    case "desktop":
      return [false, true];
    case "mobile":
      return [true, false];
    case "none":
      return [true, true];
  }
}
function debugLog(message, ...optionalParams) {
  DEBUG && console.log(message, ...optionalParams);
}
function emptyMessageFr(message) {
  let messageFr = document.createDocumentFragment();
  let messageFrText = document.createElement("i");
  messageFrText.textContent = message;
  messageFr.append(messageFrText);
  return messageFr;
}
function hasVars(s) {
  const urlVariableRegex = /{{.*?}}/g;
  return urlVariableRegex.test(s);
}
var validUrlEl;
function isValidUri(u) {
  if (u !== "") {
    if (!validUrlEl) {
      validUrlEl = document.createElement("input");
      validUrlEl.setAttribute("type", "url");
    }
    validUrlEl.value = u;
    return validUrlEl.validity.valid;
  } else {
    return false;
  }
}

// src/Settings/ToolbarSettingsModal.ts
var import_obsidian5 = require("obsidian");

// src/Settings/NoteToolbarSettings.ts
var SETTINGS_VERSION = 202404161e-1;
var DEFAULT_SETTINGS = {
  folderMappings: [],
  toolbarProp: "notetoolbar",
  toolbars: [],
  version: SETTINGS_VERSION
};
var DEFAULT_TOOLBAR_SETTINGS = {
  defaultStyles: ["border", "even", "sticky"],
  items: [],
  mobileStyles: [],
  name: "",
  positions: [{ position: "props", contexts: [{ platform: "all", view: "all" }] }],
  updated: new Date().toISOString()
};
var POSITION_OPTIONS = [
  { top: "Top (fixed)" },
  { props: "Below Properties" }
];
var DEFAULT_STYLE_OPTIONS = [
  { border: "border" },
  { button: "button" },
  { noborder: "no border" },
  { center: "center items" },
  { even: "evenly space items" },
  { left: "left align items" },
  { right: "right align items" },
  { sticky: "sticky" },
  { nosticky: "not sticky" },
  { floatl: "float left" },
  { floatr: "float right" },
  { nofloat: "no float" }
];
var MOBILE_STYLE_OPTIONS = [
  { mbrder: "border" },
  { mbtn: "button" },
  { mnbrder: "no border" },
  { mctr: "center items" },
  { mevn: "evenly space items" },
  { mlft: "left align items" },
  { mrght: "right align items" },
  { mstcky: "sticky" },
  { mnstcky: "not sticky" },
  { mfltl: "float left" },
  { mfltr: "float right" },
  { mnflt: "no float" }
];

// src/Settings/DeleteModal.ts
var import_obsidian = require("obsidian");
var DeleteModal = class extends import_obsidian.Modal {
  constructor(parent) {
    super(parent.plugin.app);
    this.modalEl.addClass("note-toolbar-setting-mini-dialog");
    this.parent = parent;
    this.plugin = parent.plugin;
    this.toolbar = parent.toolbar;
  }
  onOpen() {
    this.setTitle("Delete toolbar: " + this.toolbar.name);
    this.contentEl.createEl("p", { text: "Are you sure you want to delete this toolbar?" });
    const delete_button = this.contentEl.createEl("button", { text: "Yes, delete" });
    delete_button.onclick = async () => this.delete();
  }
  async delete() {
    this.plugin.deleteToolbarFromSettings(this.toolbar.name);
    await this.plugin.saveSettings();
    this.close();
    this.parent.close();
  }
};

// src/Settings/Suggesters/CommandSuggester.ts
var import_obsidian2 = require("obsidian");
var CommandSuggester = class extends import_obsidian2.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.commands = Object.values(this.app.commands.commands);
  }
  getSuggestions(inputStr) {
    const suggestions = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    this.commands.forEach((command) => {
      if (command.name.toLowerCase().contains(lowerCaseInputStr)) {
        suggestions.push(command);
      }
    });
    return suggestions;
  }
  renderSuggestion(command, el) {
    el.setText(command.name);
  }
  selectSuggestion(command) {
    this.inputEl.value = command.name;
    this.inputEl.setAttribute("data-command-id", command.id);
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/Settings/IconSuggestModal.ts
var import_obsidian3 = require("obsidian");
var IconSuggestModal = class extends import_obsidian3.SuggestModal {
  constructor(parent, parentEl, toolbarSettings, index) {
    super(parent.plugin.app);
    this.modalEl.addClass("note-toolbar-setting-mini-dialog");
    this.parentEl = parentEl;
    this.plugin = parent.plugin;
    this.toolbarSettings = toolbarSettings;
    this.toolbarItemIndex = index;
    this.setPlaceholder("Search for an icon");
  }
  getSuggestions(inputStr) {
    const iconIds = (0, import_obsidian3.getIconIds)();
    const iconSuggestions = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    iconSuggestions.push("No icon");
    iconIds.forEach((icon) => {
      if (icon.toLowerCase().contains(lowerCaseInputStr)) {
        iconSuggestions.push(icon);
      }
    });
    return iconSuggestions;
  }
  renderSuggestion(icon, el) {
    el.addClass("note-toolbar-icon-suggestion");
    let iconName = el.createSpan();
    if (icon === "No icon") {
      iconName.setText(icon);
    } else {
      iconName.setText(icon.startsWith("lucide-") ? icon.substring(7) : icon);
      let iconGlyph = el.createSpan();
      (0, import_obsidian3.setIcon)(iconGlyph, icon);
    }
  }
  /**
   * Saves the selected icon to settings, closes the modal, refreshes the parent.
   * @param selectedIcon Icon to save.
   */
  onChooseSuggestion(item, evt) {
    debugLog("onChooseSuggestion: ", this.toolbarItemIndex, item);
    this.toolbarSettings.items[this.toolbarItemIndex].icon = item === "No icon" ? "" : item;
    this.plugin.saveSettings();
    (0, import_obsidian3.setIcon)(this.parentEl, item === "No icon" ? "lucide-plus-square" : item);
    this.parentEl.setAttribute("data-note-toolbar-no-icon", item === "No icon" ? "true" : "false");
    this.close();
  }
};

// src/Settings/Suggesters/FileSuggester.ts
var import_obsidian4 = require("obsidian");
var FileSuggester = class extends import_obsidian4.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    let files = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    files = abstractFiles.filter(
      (file) => file instanceof import_obsidian4.TFile && file.path.toLowerCase().includes(lowerCaseInputStr)
    );
    return files;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/Settings/ToolbarSettingsModal.ts
var ToolbarSettingsModal = class extends import_obsidian5.Modal {
  /**
   * Displays a new edit toolbar modal, for the given toolbar.
   * @param app reference to the app
   * @param plugin reference to the plugin
   * @param parent NoteToolbarSettingTab if coming from settings UI; null if coming from editor 
   * @param toolbar ToolbarSettings to edit
   */
  constructor(app, plugin, parent = null, toolbar) {
    super(app);
    this.parent = parent;
    this.plugin = plugin;
    this.toolbar = toolbar;
  }
  /**
   * Displays the toolbar item's settings within the modal window.
   */
  onOpen() {
    this.display();
  }
  /**
   * Removes modal window and refreshes the parent settings window.
   */
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.parent ? this.parent.display() : void 0;
  }
  /*************************************************************************
   * SETTINGS DISPLAY
   *************************************************************************/
  /**
   * Displays the toolbar item's settings.
   */
  display(focusOnLastItem = false) {
    this.modalEl.addClass("note-toolbar-setting-modal-container");
    this.contentEl.empty();
    let settingsDiv = this.containerEl.createDiv();
    settingsDiv.className = "vertical-tab-content note-toolbar-setting-modal";
    this.displayNameSetting(settingsDiv);
    this.displayItemList(settingsDiv);
    this.displayPositionSetting(settingsDiv);
    this.displayStyleSetting(settingsDiv);
    this.displayDeleteButton(settingsDiv);
    this.contentEl.appendChild(settingsDiv);
    if (focusOnLastItem) {
      let inputToFocus = this.contentEl.querySelector("#note-toolbar-setting-item-field-" + (this.toolbar.items.length - 1) + ' input[type="text"]');
      if ((inputToFocus == null ? void 0 : inputToFocus.value.length) === 0) {
        inputToFocus.focus();
      }
    }
    this.rememberLastPosition(this.contentEl.children[0]);
  }
  /**
   * Displays the Name setting.
   * @param settingsDiv HTMLElement to add the setting to.
   */
  displayNameSetting(settingsDiv) {
    let toolbarNameDiv = this.containerEl.createDiv();
    new import_obsidian5.Setting(toolbarNameDiv).setName("Name").setDesc("Give this toolbar a unique name.").addText((text) => text.setPlaceholder("Name").setValue(this.toolbar.name).onChange((0, import_obsidian5.debounce)(async (value) => {
      var _a;
      let existingToolbar = this.plugin.getToolbarSettings(value);
      if (existingToolbar && existingToolbar !== this.toolbar) {
        toolbarNameDiv.createEl("div", {
          text: "A toolbar already exists with this name",
          attr: { id: "note-toolbar-name-error" },
          cls: "note-toolbar-setting-error-message"
        });
        toolbarNameDiv.addClass("note-toolbar-setting-error");
      } else {
        (_a = document.getElementById("note-toolbar-name-error")) == null ? void 0 : _a.remove();
        toolbarNameDiv.removeClass("note-toolbar-setting-error");
        this.toolbar.name = value;
        this.toolbar.updated = new Date().toISOString();
        this.plugin.settings.toolbars.sort((a, b) => a.name.localeCompare(b.name));
        await this.plugin.saveSettings();
      }
    }, 750)));
    settingsDiv.append(toolbarNameDiv);
  }
  /**
   * Displays the list of toolbar items for editing.
   * @param settingsDiv HTMLElement to add the settings to.
   */
  displayItemList(settingsDiv) {
    const itemsDescription = document.createDocumentFragment();
    itemsDescription.append(
      "Items that appear in the toolbar, in order.",
      itemsDescription.createEl("br"),
      "See the documentation for ",
      itemsDescription.createEl("a", {
        href: "https://github.com/chrisgurney/obsidian-note-toolbar/wiki/Examples",
        text: "examples"
      }),
      ", and for details about ",
      itemsDescription.createEl("a", {
        href: "https://github.com/chrisgurney/obsidian-note-toolbar/wiki/Variables",
        text: "variables"
      }),
      " supported."
    );
    new import_obsidian5.Setting(settingsDiv).setName("Items").setDesc(itemsDescription).setClass("note-toolbar-setting-no-controls");
    let itemLinkFields = [];
    let itemVisToggles = [];
    this.toolbar.items.forEach(
      (toolbarItem, index) => {
        let itemDiv = this.containerEl.createDiv();
        itemDiv.className = "note-toolbar-setting-item";
        let itemTopContainer = this.containerEl.createDiv();
        itemTopContainer.className = "note-toolbar-setting-item-top-container";
        let textFieldsContainer = this.containerEl.createDiv();
        textFieldsContainer.id = "note-toolbar-setting-item-field-" + index;
        textFieldsContainer.className = "note-toolbar-setting-item-fields";
        const s1a = new import_obsidian5.Setting(textFieldsContainer).setClass("note-toolbar-setting-item-icon").addExtraButton((cb) => {
          cb.setIcon(toolbarItem.icon ? toolbarItem.icon : "lucide-plus-square").setTooltip("Select icon (optional)").onClick(async () => {
            const modal = new IconSuggestModal(this, cb.extraSettingsEl, this.toolbar, index);
            modal.open();
          });
          cb.extraSettingsEl.setAttribute("data-note-toolbar-no-icon", !toolbarItem.icon ? "true" : "false");
          cb.extraSettingsEl.setAttribute("tabindex", "0");
          this.plugin.registerDomEvent(
            cb.extraSettingsEl,
            "keydown",
            (e) => {
              switch (e.key) {
                case "Enter":
                case " ":
                  const modal = new IconSuggestModal(this, cb.extraSettingsEl, this.toolbar, index);
                  modal.open();
                  e.preventDefault();
              }
            }
          );
        });
        const s1b = new import_obsidian5.Setting(textFieldsContainer).setClass("note-toolbar-setting-item-field").addText((text) => text.setPlaceholder("Label (optional, if icon set)").setValue(toolbarItem.label).onChange(
          (0, import_obsidian5.debounce)(async (value) => {
            toolbarItem.label = value;
            this.toolbar.updated = new Date().toISOString();
            await this.plugin.saveSettings();
          }, 750)
        ));
        const s1c = new import_obsidian5.Setting(textFieldsContainer).setClass("note-toolbar-setting-item-field").addText((text) => text.setPlaceholder("Tooltip (optional)").setValue(toolbarItem.tooltip).onChange(
          (0, import_obsidian5.debounce)(async (value) => {
            toolbarItem.tooltip = value;
            this.toolbar.updated = new Date().toISOString();
            await this.plugin.saveSettings();
          }, 750)
        ));
        let linkContainerDiv = this.containerEl.createDiv();
        linkContainerDiv.className = "note-toolbar-setting-item-link-container";
        let linkTypeDiv = this.containerEl.createDiv();
        const s1t = new import_obsidian5.Setting(linkTypeDiv).addDropdown(
          (dropdown) => dropdown.addOptions({ command: "Command", file: "File", uri: "URI" }).setValue(toolbarItem.linkAttr.type).onChange(async (value) => {
            toolbarItem.linkAttr.type = value;
            switch (value) {
              case "command":
                toolbarItem.link = "";
                itemLinkFields[index].command.settingEl.setAttribute("data-active", "true");
                itemLinkFields[index].file.settingEl.setAttribute("data-active", "false");
                itemLinkFields[index].uri.settingEl.setAttribute("data-active", "false");
                break;
              case "file":
                itemLinkFields[index].command.settingEl.setAttribute("data-active", "false");
                itemLinkFields[index].file.settingEl.setAttribute("data-active", "true");
                itemLinkFields[index].uri.settingEl.setAttribute("data-active", "false");
                break;
              case "uri":
                itemLinkFields[index].command.settingEl.setAttribute("data-active", "false");
                itemLinkFields[index].file.settingEl.setAttribute("data-active", "false");
                itemLinkFields[index].uri.settingEl.setAttribute("data-active", "true");
                break;
            }
            await this.plugin.saveSettings();
            this.display();
          })
        );
        let linkFieldDiv = this.containerEl.createDiv();
        linkFieldDiv.className = "note-toolbar-setting-item-link-container";
        let linkCommandFieldDiv = this.containerEl.createDiv();
        let linkFileFieldDiv = this.containerEl.createDiv();
        let linkUriFieldDiv = this.containerEl.createDiv();
        itemLinkFields.push({
          //
          // command
          //
          command: new import_obsidian5.Setting(linkCommandFieldDiv).setClass("note-toolbar-setting-item-field-link").addSearch((cb) => {
            new CommandSuggester(this.app, cb.inputEl);
            cb.setPlaceholder("Search for command").setValue(toolbarItem.link).onChange((0, import_obsidian5.debounce)(async (command) => {
              var _a, _b;
              toolbarItem.link = command;
              toolbarItem.linkAttr.type = "command";
              toolbarItem.linkAttr.commandId = (_b = (_a = cb.inputEl) == null ? void 0 : _a.getAttribute("data-command-id")) != null ? _b : "";
              await this.plugin.saveSettings();
            }, 250));
          }),
          //
          // file
          //
          file: new import_obsidian5.Setting(linkFileFieldDiv).setClass("note-toolbar-setting-item-field-link").addSearch((cb) => {
            new FileSuggester(this.app, cb.inputEl);
            cb.setPlaceholder("Search for file").setValue(toolbarItem.link).onChange((0, import_obsidian5.debounce)(async (value) => {
              var _a;
              toolbarItem.linkAttr.type = "file";
              const file = this.app.vault.getAbstractFileByPath(value);
              if (!(file instanceof import_obsidian5.TFile)) {
                if (document.getElementById("note-toolbar-item-link-note-error") === null) {
                  let errorDiv = this.containerEl.createEl("div", {
                    text: "This file does not exist.",
                    attr: { id: "note-toolbar-item-link-note-error" },
                    cls: "note-toolbar-setting-error-message"
                  });
                  linkContainerDiv.insertAdjacentElement("afterend", errorDiv);
                  itemLinkFields[index].file.settingEl.children[1].addClass("note-toolbar-setting-error");
                }
              } else {
                toolbarItem.link = (0, import_obsidian5.normalizePath)(value);
                toolbarItem.linkAttr.commandId = "";
                (_a = document.getElementById("note-toolbar-item-link-note-error")) == null ? void 0 : _a.remove();
                itemLinkFields[index].file.settingEl.children[1].removeClass("note-toolbar-setting-error");
                await this.plugin.saveSettings();
              }
            }, 750));
          }),
          //
          // URI
          //
          uri: new import_obsidian5.Setting(linkUriFieldDiv).setClass("note-toolbar-setting-item-field-link").addText((text) => text.setPlaceholder("Website, URI, or note title").setValue(toolbarItem.link).onChange(
            (0, import_obsidian5.debounce)(async (value) => {
              toolbarItem.link = value;
              toolbarItem.linkAttr.type = "uri";
              toolbarItem.linkAttr.hasVars = hasVars(value);
              toolbarItem.linkAttr.commandId = "";
              this.toolbar.updated = new Date().toISOString();
              await this.plugin.saveSettings();
            }, 750)
          ))
        });
        linkFieldDiv.append(itemLinkFields[index].command.settingEl);
        linkFieldDiv.append(itemLinkFields[index].file.settingEl);
        linkFieldDiv.append(itemLinkFields[index].uri.settingEl);
        itemLinkFields[index].command.settingEl.setAttribute(
          "data-active",
          toolbarItem.linkAttr.type === "command" ? "true" : "false"
        );
        itemLinkFields[index].file.settingEl.setAttribute(
          "data-active",
          toolbarItem.linkAttr.type === "file" ? "true" : "false"
        );
        itemLinkFields[index].uri.settingEl.setAttribute(
          "data-active",
          toolbarItem.linkAttr.type === "uri" ? "true" : "false"
        );
        linkContainerDiv.append(linkTypeDiv);
        linkContainerDiv.append(linkFieldDiv);
        let itemControlsDiv = this.containerEl.createDiv();
        itemControlsDiv.className = "note-toolbar-setting-item-controls";
        const s1d = new import_obsidian5.Setting(itemControlsDiv).addExtraButton((cb) => {
          cb.setIcon("up-chevron-glyph").setTooltip("Move up").onClick(async () => this.listMoveHandler(null, this.toolbar.items, index, "up"));
          cb.extraSettingsEl.setAttribute("tabindex", "0");
          this.plugin.registerDomEvent(
            cb.extraSettingsEl,
            "keydown",
            (e) => this.listMoveHandler(e, this.toolbar.items, index, "up")
          );
        }).addExtraButton((cb) => {
          cb.setIcon("down-chevron-glyph").setTooltip("Move down").onClick(async () => this.listMoveHandler(null, this.toolbar.items, index, "down"));
          cb.extraSettingsEl.setAttribute("tabindex", "0");
          this.plugin.registerDomEvent(
            cb.extraSettingsEl,
            "keydown",
            (e) => this.listMoveHandler(e, this.toolbar.items, index, "down")
          );
        }).addExtraButton((cb) => {
          cb.setIcon("cross").setTooltip("Delete").onClick(async () => this.listMoveHandler(null, this.toolbar.items, index, "delete"));
          cb.extraSettingsEl.setAttribute("tabindex", "0");
          this.plugin.registerDomEvent(
            cb.extraSettingsEl,
            "keydown",
            (e) => this.listMoveHandler(e, this.toolbar.items, index, "delete")
          );
        });
        let itemFieldsControlsContainer = this.containerEl.createDiv();
        itemFieldsControlsContainer.className = "note-toolbar-setting-item-fields-and-controls";
        itemFieldsControlsContainer.appendChild(textFieldsContainer);
        itemFieldsControlsContainer.appendChild(itemControlsDiv);
        itemTopContainer.appendChild(itemFieldsControlsContainer);
        itemTopContainer.appendChild(linkContainerDiv);
        itemDiv.appendChild(itemTopContainer);
        const [hideOnDesktopValue, hideOnMobileValue] = calcItemVisToggles(toolbarItem.contexts[0].platform);
        itemVisToggles.push({
          hideOnDesktop: hideOnDesktopValue,
          hideOnMobile: hideOnMobileValue
        });
        let togglesContainer = this.containerEl.createDiv();
        togglesContainer.className = "note-toolbar-setting-item-toggles-container";
        const s2 = new import_obsidian5.Setting(togglesContainer).setClass("note-toolbar-setting-item-toggle").setName("Hide on: mobile").addToggle((toggle) => {
          toggle.setTooltip("If enabled, this item will not appear on mobile").setValue(itemVisToggles[index].hideOnMobile).onChange(async (hideOnMobile) => {
            itemVisToggles[index].hideOnMobile = hideOnMobile;
            toolbarItem.contexts = [{
              platform: calcItemVisPlatform(itemVisToggles[index].hideOnDesktop, itemVisToggles[index].hideOnMobile),
              view: "all"
            }];
            this.toolbar.updated = new Date().toISOString();
            await this.plugin.saveSettings();
          });
        });
        const s3 = new import_obsidian5.Setting(togglesContainer).setClass("note-toolbar-setting-item-toggle").setName("desktop").addToggle((toggle) => {
          toggle.setTooltip("If enabled, this item will not appear on desktop").setValue(itemVisToggles[index].hideOnDesktop).onChange(async (hideOnDesktop) => {
            itemVisToggles[index].hideOnDesktop = hideOnDesktop;
            toolbarItem.contexts = [{
              platform: calcItemVisPlatform(itemVisToggles[index].hideOnDesktop, itemVisToggles[index].hideOnMobile),
              view: "all"
            }];
            this.toolbar.updated = new Date().toISOString();
            await this.plugin.saveSettings();
          });
        });
        itemDiv.appendChild(togglesContainer);
        settingsDiv.appendChild(itemDiv);
      }
    );
    new import_obsidian5.Setting(settingsDiv).setClass("note-toolbar-setting-button").addButton((button) => {
      button.setTooltip("Add a new item to the toolbar").setButtonText("+ Add toolbar item").setCta().onClick(async () => {
        var _a, _b;
        this.toolbar.items.push({
          label: "",
          icon: "",
          link: "",
          linkAttr: {
            commandId: "",
            hasVars: false,
            type: (_b = (_a = this.toolbar.items.last()) == null ? void 0 : _a.linkAttr.type) != null ? _b : "uri"
          },
          tooltip: "",
          contexts: [{ platform: "all", view: "all" }]
        });
        this.toolbar.updated = new Date().toISOString();
        await this.plugin.saveSettings();
        this.display(true);
      });
    });
  }
  /**
   * Displays the Position setting.
   * @param settingsDiv HTMLElement to add the settings to.
   */
  displayPositionSetting(settingsDiv) {
    new import_obsidian5.Setting(settingsDiv).setName("Position").setDesc("Where to position this toolbar.").setClass("note-toolbar-setting-spaced").addDropdown(
      (dropdown) => dropdown.addOptions(
        POSITION_OPTIONS.reduce((acc, option) => {
          return { ...acc, ...option };
        }, {})
      ).setValue(this.toolbar.positions[0].position).onChange(async (val) => {
        this.toolbar.positions = [{ position: val, contexts: [{ platform: "all", view: "all" }] }];
        this.toolbar.updated = new Date().toISOString();
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
  /**
   * Displays the Style settings.
   * @param settingsDiv HTMLElement to add the settings to.
   */
  displayStyleSetting(settingsDiv) {
    const stylingDescription = document.createDocumentFragment();
    stylingDescription.append(
      "List of styles to apply to the toolbar (default: border even sticky).",
      stylingDescription.createEl("br"),
      "Sticky does not apply in Reading mode. See the ",
      stylingDescription.createEl("a", {
        href: "https://github.com/chrisgurney/obsidian-note-toolbar/wiki/Styling-toolbars",
        text: "documentation"
      }),
      " about the list of supported styles."
    );
    new import_obsidian5.Setting(settingsDiv).setName("Styles").setDesc(stylingDescription).setClass("note-toolbar-setting-no-controls");
    let defaultStyleDiv = this.containerEl.createDiv();
    defaultStyleDiv.className = "note-toolbar-setting-item-style";
    if (this.toolbar.defaultStyles.length == 0) {
      let emptyMsg = this.containerEl.createEl(
        "div",
        { text: emptyMessageFr("No default styles set.") }
      );
      emptyMsg.className = "note-toolbar-setting-empty-message";
      defaultStyleDiv.append(emptyMsg);
    } else {
      this.toolbar.defaultStyles.forEach(
        (style, index) => {
          new import_obsidian5.Setting(defaultStyleDiv).setName(this.getValueForKey(DEFAULT_STYLE_OPTIONS, style)).setTooltip("Use in Callout or CSS: " + style).addExtraButton((cb) => {
            cb.setIcon("cross").setTooltip("Remove").onClick(async () => this.listMoveHandler(null, this.toolbar.defaultStyles, index, "delete"));
            cb.extraSettingsEl.setAttribute("tabindex", "0");
            this.plugin.registerDomEvent(
              cb.extraSettingsEl,
              "keydown",
              (e) => this.listMoveHandler(e, this.toolbar.defaultStyles, index, "delete")
            );
          });
        }
      );
    }
    new import_obsidian5.Setting(defaultStyleDiv).addDropdown(
      (dropdown) => dropdown.addOptions(
        DEFAULT_STYLE_OPTIONS.reduce((acc, option) => {
          return { ...acc, ...option };
        }, {})
      ).setValue("").onChange(async (val) => {
        if (this.toolbar.defaultStyles.includes(val)) {
          this.toolbar.defaultStyles = this.toolbar.defaultStyles.filter((i) => i !== val);
        } else {
          this.toolbar.defaultStyles.push(val);
        }
        await this.plugin.saveSettings();
        this.display();
      })
    );
    new import_obsidian5.Setting(settingsDiv).setName("Default").setDesc("Applies to all unless overridden.").setClass("note-toolbar-setting-item-styles").settingEl.append(defaultStyleDiv);
    let mobileStyleDiv = this.containerEl.createDiv();
    mobileStyleDiv.className = "note-toolbar-setting-item-style";
    if (this.toolbar.mobileStyles.length == 0) {
      let emptyMsg = this.containerEl.createEl(
        "div",
        { text: emptyMessageFr("No mobile styles set.") }
      );
      emptyMsg.className = "note-toolbar-setting-empty-message";
      mobileStyleDiv.append(emptyMsg);
    } else {
      this.toolbar.mobileStyles.forEach(
        (style, index) => {
          new import_obsidian5.Setting(mobileStyleDiv).setName(this.getValueForKey(MOBILE_STYLE_OPTIONS, style)).setTooltip("Use in Callout or CSS: " + style).addExtraButton((cb) => {
            cb.setIcon("cross").setTooltip("Remove").onClick(async () => this.listMoveHandler(null, this.toolbar.mobileStyles, index, "delete"));
            cb.extraSettingsEl.setAttribute("tabindex", "0");
            this.plugin.registerDomEvent(
              cb.extraSettingsEl,
              "keydown",
              (e) => this.listMoveHandler(e, this.toolbar.mobileStyles, index, "delete")
            );
          });
        }
      );
    }
    new import_obsidian5.Setting(mobileStyleDiv).addDropdown(
      (dropdown) => dropdown.addOptions(
        MOBILE_STYLE_OPTIONS.reduce((acc, option) => {
          return { ...acc, ...option };
        }, {})
      ).setValue(this.toolbar.mobileStyles.join(", ") || "").onChange(async (val) => {
        if (this.toolbar.mobileStyles.includes(val)) {
          this.toolbar.mobileStyles = this.toolbar.mobileStyles.filter((i) => i !== val);
        } else {
          this.toolbar.mobileStyles.push(val);
        }
        await this.plugin.saveSettings();
        this.display();
      })
    );
    new import_obsidian5.Setting(settingsDiv).setName("Mobile").setDesc("Override default styles.").setClass("note-toolbar-setting-item-styles").settingEl.append(mobileStyleDiv);
  }
  /**
   * Displays the Delete button.
   * @param settingsDiv HTMLElement to add the settings to.
   */
  displayDeleteButton(settingsDiv) {
    new import_obsidian5.Setting(settingsDiv).setName("Delete this toolbar").setDesc("This action cannot be undone.").setClass("note-toolbar-setting-spaced").addButton((button) => {
      button.setClass("mod-warning").setTooltip("Delete this toolbar").setButtonText("Delete...").setCta().onClick(() => {
        const modal = new DeleteModal(this);
        modal.open();
      });
    });
  }
  /*************************************************************************
   * SETTINGS DISPLAY HANDLERS
   *************************************************************************/
  /**
   * Handles moving items within a list, and deletion, based on click or keyboard event.
   * @param keyEvent KeyboardEvent, if the keyboard is triggering this handler.
   * @param itemArray Array that we're operating on.
   * @param index Number of the item in the list we're moving/deleting.
   * @param action Direction of the move, or "delete".
   */
  async listMoveHandler(keyEvent, itemArray, index, action) {
    if (keyEvent) {
      switch (keyEvent.key) {
        case "ArrowUp":
          action = "up";
          break;
        case "ArrowDown":
          action = "down";
          break;
        case "Enter":
        case " ":
          break;
        default:
          return;
      }
    }
    switch (action) {
      case "up":
        arraymove(itemArray, index, index - 1);
        this.toolbar.updated = new Date().toISOString();
        keyEvent == null ? void 0 : keyEvent.preventDefault();
        break;
      case "down":
        arraymove(itemArray, index, index + 1);
        this.toolbar.updated = new Date().toISOString();
        keyEvent == null ? void 0 : keyEvent.preventDefault();
        break;
      case "delete":
        itemArray.splice(index, 1);
        this.toolbar.updated = new Date().toISOString();
        keyEvent == null ? void 0 : keyEvent.preventDefault();
        break;
    }
    await this.plugin.saveSettings();
    this.display();
  }
  /**
   * Remembers the scrolling position of the user and jumps to it on display.
   * @author Taitava (Shell Commands plugin)
   * @link https://github.com/Taitava/obsidian-shellcommands/blob/8d030a23540d587a85bd0dfe2e08c8e6b6b955ab/src/settings/SC_MainSettingsTab.ts#L701 
  */
  rememberLastPosition(containerEl) {
    debugLog("rememberLastPosition:", containerEl);
    containerEl.scrollTo({
      top: this.lastScrollPosition,
      behavior: "auto"
    });
    this.plugin.registerDomEvent(containerEl, "scroll", (event) => {
      this.lastScrollPosition = containerEl.scrollTop;
    });
  }
  /*************************************************************************
   * UTILITIES
   *************************************************************************/
  /**
   * Returns the value for the provided key from the provided dictionary.
   * @param dict key-value dictionary
   * @param key string key
   * @returns value from the dictionary
   */
  getValueForKey(dict, key) {
    const option = dict.find((option2) => key in option2);
    return option ? Object.values(option)[0] : "INVALID OPTION";
  }
};

// src/Settings/Suggesters/FolderSuggester.ts
var import_obsidian6 = require("obsidian");
var FolderSuggester = class extends import_obsidian6.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian6.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/Settings/Suggesters/ToolbarSuggester.ts
var import_obsidian7 = require("obsidian");
var ToolbarSuggester = class extends import_obsidian7.AbstractInputSuggest {
  constructor(app, plugin, inputEl) {
    super(app, inputEl);
    this.plugin = plugin;
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    const pluginToolbars = this.plugin.settings.toolbars;
    const toolbarSuggestions = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    pluginToolbars.forEach((toolbar) => {
      if (toolbar.name.toLowerCase().contains(lowerCaseInputStr)) {
        toolbarSuggestions.push(toolbar);
      }
    });
    return toolbarSuggestions;
  }
  renderSuggestion(toolbar, el) {
    el.setText(toolbar.name);
  }
  selectSuggestion(toolbar) {
    this.inputEl.value = toolbar.name;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/Settings/NoteToolbarSettingTab.ts
var NoteToolbarSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.app = app;
    this.plugin = plugin;
  }
  openSettingsModal(toolbar) {
    const modal = new ToolbarSettingsModal(this.app, this.plugin, this, toolbar);
    modal.setTitle("Edit Toolbar");
    modal.open();
  }
  /*************************************************************************
   * SETTINGS DISPLAY
   *************************************************************************/
  /**
   * Displays the main settings.
   */
  display(focusOnLastItem = false) {
    const { containerEl } = this;
    containerEl.empty();
    this.displayToolbarList(containerEl);
    new import_obsidian8.Setting(containerEl).setName("Display rules").setHeading();
    this.displayPropertySetting(containerEl);
    this.displayFolderMap(containerEl);
    if (focusOnLastItem) {
      let inputToFocus = this.containerEl.querySelector(
        "#note-toolbar-setting-item-field-" + (this.plugin.settings.folderMappings.length - 1) + ' input[type="search"]'
      );
      if ((inputToFocus == null ? void 0 : inputToFocus.value.length) === 0) {
        inputToFocus.focus();
      }
    }
    this.rememberLastPosition(this.containerEl);
  }
  /**
   * Displays the list of toolbars.
   * @param containerEl HTMLElement to add the settings to.
   */
  displayToolbarList(containerEl) {
    const toolbarsDesc = document.createDocumentFragment();
    toolbarsDesc.append(
      "Define the toolbars you want to add to your notes. ",
      toolbarsDesc.createEl("a", {
        href: "https://github.com/chrisgurney/obsidian-note-toolbar/wiki",
        text: "User Guide"
      }),
      " \u2022\xA0",
      toolbarsDesc.createEl("a", {
        href: "https://github.com/chrisgurney/obsidian-note-toolbar/releases",
        text: "v" + this.plugin.manifest.version
      })
    );
    new import_obsidian8.Setting(containerEl).setName("Toolbars").setDesc(toolbarsDesc).setClass("note-toolbar-setting-no-controls");
    if (this.plugin.settings.toolbars.length == 0) {
      containerEl.createEl("div", { text: emptyMessageFr("Click the button to create a toolbar.") }).className = "note-toolbar-setting-empty-message";
    } else {
      let toolbarListDiv = containerEl.createDiv();
      toolbarListDiv.addClass("note-toolbar-setting-toolbar-list");
      this.plugin.settings.toolbars.forEach(
        (toolbarItem, index) => {
          new import_obsidian8.Setting(toolbarListDiv).setName(toolbarItem.name).setDesc(this.createToolbarPreviewFr(toolbarItem.items)).addButton((button) => {
            button.setTooltip("Update this toolbar's items").setButtonText("Edit").setCta().onClick(() => {
              this.openSettingsModal(toolbarItem);
            });
          });
        }
      );
      containerEl.append(toolbarListDiv);
    }
    new import_obsidian8.Setting(containerEl).setClass("note-toolbar-setting-button").addButton((button) => {
      button.setTooltip("Add a new toolbar").setButtonText("+ New toolbar").setCta().onClick(async () => {
        let newToolbar = {
          defaultStyles: ["border", "even", "sticky"],
          items: [],
          mobileStyles: [],
          name: "",
          positions: [{ position: "props", contexts: [{ platform: "all", view: "all" }] }],
          updated: new Date().toISOString()
        };
        this.plugin.settings.toolbars.push(newToolbar);
        await this.plugin.saveSettings();
        this.openSettingsModal(newToolbar);
      });
    });
  }
  /**
   * Displays the property setting.
   * @param containerEl HTMLElement to add the settings to.
   */
  displayPropertySetting(containerEl) {
    new import_obsidian8.Setting(containerEl).setName("Property").setDesc("If a toolbar name is found in this property, the toolbar will be displayed on the note. Takes precedence over any folder mappings.").addText((text) => text.setPlaceholder("Property").setValue(this.plugin.settings.toolbarProp).onChange((0, import_obsidian8.debounce)(async (value) => {
      this.plugin.settings.toolbarProp = value;
      await this.plugin.saveSettings();
    }, 750)));
  }
  /**
   * Displays the folder mappings.
   * @param containerEl HTMLElement to add the settings to.
   */
  displayFolderMap(containerEl) {
    new import_obsidian8.Setting(containerEl).setName("Folder mappings").setDesc("Notes in folders below will display the toolbar mapped to it. Precedence is top to bottom.").setClass("note-toolbar-setting-no-controls");
    if (this.plugin.settings.folderMappings.length == 0) {
      containerEl.createEl("div", { text: emptyMessageFr("Click the button to create a mapping.") }).className = "note-toolbar-setting-empty-message";
    } else {
      let toolbarFolderListDiv = containerEl.createDiv();
      this.plugin.settings.folderMappings.forEach(
        (mapping, index) => {
          let toolbarFolderListItemDiv = containerEl.createDiv();
          toolbarFolderListItemDiv.className = "note-toolbar-setting-folder-list-item-container";
          let textFieldsDiv = this.containerEl.createDiv();
          textFieldsDiv.id = "note-toolbar-setting-item-field-" + index;
          textFieldsDiv.className = "note-toolbar-setting-item-fields";
          const fs = new import_obsidian8.Setting(textFieldsDiv).setClass("note-toolbar-setting-item-field").addSearch((cb) => {
            new FolderSuggester(this.app, cb.inputEl);
            cb.setPlaceholder("Folder").setValue(mapping.folder).onChange((0, import_obsidian8.debounce)(async (newFolder) => {
              var _a;
              if (newFolder && this.plugin.settings.folderMappings.some(
                (mapping2, mapIndex) => {
                  return index != mapIndex ? mapping2.folder.toLowerCase() === newFolder.toLowerCase() : void 0;
                }
              )) {
                if (document.getElementById("note-toolbar-name-error") === null) {
                  let errorDiv = containerEl.createEl("div", {
                    text: "This folder already has a toolbar associated with it.",
                    attr: { id: "note-toolbar-name-error" },
                    cls: "note-toolbar-setting-error-message"
                  });
                  toolbarFolderListItemDiv.insertAdjacentElement("afterend", errorDiv);
                  toolbarFolderListItemDiv.children[0].addClass("note-toolbar-setting-error");
                }
              } else {
                (_a = document.getElementById("note-toolbar-name-error")) == null ? void 0 : _a.remove();
                toolbarFolderListItemDiv.children[0].removeClass("note-toolbar-setting-error");
                this.plugin.settings.folderMappings[index].folder = newFolder ? (0, import_obsidian8.normalizePath)(newFolder) : "";
                await this.plugin.saveSettings();
              }
            }, 250));
          });
          const ts = new import_obsidian8.Setting(textFieldsDiv).setClass("note-toolbar-setting-item-field").addSearch((cb) => {
            new ToolbarSuggester(this.app, this.plugin, cb.inputEl);
            cb.setPlaceholder("Toolbar").setValue(mapping.toolbar).onChange((0, import_obsidian8.debounce)(async (newToolbar) => {
              this.plugin.settings.folderMappings[index].toolbar = newToolbar;
              await this.plugin.saveSettings();
            }, 250));
          });
          let itemControlsDiv = this.containerEl.createDiv();
          itemControlsDiv.className = "note-toolbar-setting-item-controls";
          const s1d = new import_obsidian8.Setting(itemControlsDiv).addExtraButton((cb) => {
            cb.setIcon("up-chevron-glyph").setTooltip("Move up").onClick(async () => this.listMoveHandler(null, index, "up"));
            cb.extraSettingsEl.setAttribute("tabindex", "0");
            this.plugin.registerDomEvent(
              cb.extraSettingsEl,
              "keydown",
              (e) => this.listMoveHandler(e, index, "up")
            );
          }).addExtraButton((cb) => {
            cb.setIcon("down-chevron-glyph").setTooltip("Move down").onClick(async () => this.listMoveHandler(null, index, "down"));
            cb.extraSettingsEl.setAttribute("tabindex", "0");
            this.plugin.registerDomEvent(
              cb.extraSettingsEl,
              "keydown",
              (e) => this.listMoveHandler(e, index, "down")
            );
          }).addExtraButton((cb) => {
            cb.setIcon("cross").setTooltip("Delete").onClick(async () => this.listMoveHandler(null, index, "delete"));
            cb.extraSettingsEl.setAttribute("tabindex", "0");
            this.plugin.registerDomEvent(
              cb.extraSettingsEl,
              "keydown",
              (e) => this.listMoveHandler(e, index, "delete")
            );
          });
          toolbarFolderListItemDiv.append(textFieldsDiv);
          toolbarFolderListItemDiv.append(itemControlsDiv);
          toolbarFolderListDiv.append(toolbarFolderListItemDiv);
        }
      );
      containerEl.append(toolbarFolderListDiv);
    }
    new import_obsidian8.Setting(containerEl).setClass("note-toolbar-setting-button").addButton((button) => {
      button.setTooltip("Add a new mapping").setButtonText("+ New mapping").setCta().onClick(async () => {
        let newMapping = {
          folder: "",
          toolbar: ""
        };
        this.plugin.settings.folderMappings.push(newMapping);
        await this.plugin.saveSettings();
        this.display(true);
      });
    });
  }
  /*************************************************************************
   * SETTINGS DISPLAY HANDLERS
   *************************************************************************/
  /**
   * Handles moving mappings up and down the list, and deletion, based on click or keyboard event.
   * @param keyEvent KeyboardEvent, if the keyboard is triggering this handler.
   * @param index Number of the item in the list we're moving/deleting.
   * @param direction Direction of the move, or "delete".
   */
  async listMoveHandler(keyEvent, index, direction) {
    if (keyEvent) {
      switch (keyEvent.key) {
        case "ArrowUp":
          direction = "up";
          break;
        case "ArrowDown":
          direction = "down";
          break;
        case "Enter":
          break;
        default:
          return;
      }
    }
    switch (direction) {
      case "up":
        arraymove(this.plugin.settings.folderMappings, index, index - 1);
        keyEvent == null ? void 0 : keyEvent.preventDefault();
        break;
      case "down":
        arraymove(this.plugin.settings.folderMappings, index, index + 1);
        keyEvent == null ? void 0 : keyEvent.preventDefault();
        break;
      case "delete":
        this.plugin.settings.folderMappings.splice(index, 1);
        keyEvent == null ? void 0 : keyEvent.preventDefault();
        break;
    }
    await this.plugin.saveSettings();
    this.display();
  }
  /**
   * Remembers the scrolling position of the user and jumps to it on display.
   * @author Taitava (Shell Commands plugin)
   * @link https://github.com/Taitava/obsidian-shellcommands/blob/8d030a23540d587a85bd0dfe2e08c8e6b6b955ab/src/settings/SC_MainSettingsTab.ts#L701 
  */
  rememberLastPosition(containerEl) {
    debugLog("rememberLastPosition:", containerEl);
    containerEl.scrollTo({
      top: this.lastScrollPosition,
      behavior: "auto"
    });
    this.plugin.registerDomEvent(containerEl, "scroll", (event) => {
      this.lastScrollPosition = containerEl.scrollTop;
    });
  }
  /*************************************************************************
   * UTILITIES
   *************************************************************************/
  /**
   * Constructs a preview of the given toolbar, including the icons used.
   * @param toolbarItems Array of ToolbarItemSettings to display in the preview.
   * @returns DocumentFragment
   */
  createToolbarPreviewFr(toolbarItems) {
    let toolbarFr = document.createDocumentFragment();
    if (toolbarItems.length > 0) {
      toolbarItems.filter((item) => {
        return item.label === "" && item.icon === "" ? false : true;
      }).map((item) => {
        let itemFr = toolbarFr.createDiv();
        itemFr.addClass("note-toolbar-setting-toolbar-list-preview-item");
        let iconFr = toolbarFr.createSpan();
        let labelFr = toolbarFr.createSpan();
        if (item.icon) {
          (0, import_obsidian8.setIcon)(iconFr, item.icon);
          toolbarFr.append(iconFr);
        }
        if (item.label) {
          labelFr.textContent = item.label;
          toolbarFr.append(labelFr);
        }
        itemFr.append(iconFr, labelFr);
        toolbarFr.append(itemFr);
      });
    } else {
      toolbarFr = emptyMessageFr("No toolbar items. Click Edit to update this toolbar.");
    }
    return toolbarFr;
  }
};

// src/main.ts
var NoteToolbarPlugin = class extends import_obsidian9.Plugin {
  constructor() {
    super(...arguments);
    /* keeping for potential future use
    	async storeLeafId(currentView: MarkdownView) {
    		// @ts-ignore
    		this.activeLeafIds.push(currentView?.file?.path + '_' + currentView?.leaf.id);
    	}
    
    	haveLeafId(currentView: MarkdownView): boolean {
    		// @ts-ignore
    		return this.activeLeafIds.contains(currentView?.file?.path + '_' + currentView?.leaf.id);
    	}
    
    	async removeLeafId(idToRemove: string) {
    		// not sure when to call this; can't find event that's fired when leaf closes
    		this.activeLeafIds.remove(idToRemove);
    	}
    	*/
    /*************************************************************************
     * LISTENERS
     *************************************************************************/
    /**
     * On opening of a file, check and render toolbar if necessary.
     * @param file TFile that was opened.
     */
    this.fileOpenListener = (file) => {
      var _a;
      if (file != null) {
        debugLog("file-open: " + file.name);
        this.checkAndRenderToolbar(file, (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter);
      }
    };
    /**
     * On layout changes, delete, check and render toolbar if necessary.
     */
    this.layoutChangeListener = () => {
      let currentView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
      let viewMode = currentView == null ? void 0 : currentView.getMode();
      debugLog("===== LAYOUT-CHANGE ===== ", viewMode);
      switch (viewMode) {
        case "source":
        case "preview":
          debugLog("layout-change: ", viewMode, " -> re-rendering toolbar");
          this.removeActiveToolbar();
          this.app.workspace.onLayoutReady((0, import_obsidian9.debounce)(() => {
            debugLog("LAYOUT READY");
            this.renderToolbarForActiveFile();
          }, viewMode === "preview" ? 200 : 0));
          break;
        default:
          return;
      }
    };
    /**
     * On leaf changes, delete, check and render toolbar if necessary. 
     */
    this.leafChangeListener = (event) => {
      var _a;
      let currentView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
      let viewMode = currentView == null ? void 0 : currentView.getMode();
      debugLog("===== LEAF-CHANGE ===== ", viewMode, event);
      debugLog((_a = currentView == null ? void 0 : currentView.file) == null ? void 0 : _a.path, currentView == null ? void 0 : currentView.leaf.id);
      switch (viewMode) {
        case "source":
        case "preview":
          debugLog("leaf-change: ", viewMode, " -> re-rendering toolbar");
          this.removeActiveToolbar();
          this.renderToolbarForActiveFile();
          break;
        default:
          return;
      }
    };
    /**
     * On changes to metadata, trigger the checks and rendering of a toolbar if necessary.
     * @param file TFile in which metadata changed.
     * @param data ??? (not used)
     * @param cache CachedMetadata, from which we look at the frontmatter.
     */
    this.metadataCacheListener = (file, data, cache) => {
      debugLog("metadata-changed: " + file.name);
      if (this.app.workspace.getActiveFile() === file) {
        this.checkAndRenderToolbar(file, cache.frontmatter);
      }
    };
  }
  /**
   * When this plugin is loaded (e.g., on Obsidian startup, or plugin is enabled in settings):
   * adds listeners, settings, and renders the toolbar for the active file.
   */
  async onload() {
    await this.loadSettings();
    this.registerEvent(this.app.workspace.on("active-leaf-change", this.leafChangeListener));
    this.registerEvent(this.app.metadataCache.on("changed", this.metadataCacheListener));
    this.registerEvent(this.app.workspace.on("layout-change", this.layoutChangeListener));
    this.addCommand({ id: "focus", name: "Focus", callback: async () => this.focusCommand() });
    this.addCommand({ id: "open-settings", name: "Open Plugin Settings", callback: async () => this.openSettingsCommand() });
    this.addCommand({ id: "show-properties", name: "Show Properties", callback: async () => this.togglePropsCommand("show") });
    this.addCommand({ id: "hide-properties", name: "Hide Properties", callback: async () => this.togglePropsCommand("hide") });
    this.addCommand({ id: "toggle-properties", name: "Toggle Properties", callback: async () => this.togglePropsCommand("toggle") });
    this.addSettingTab(new NoteToolbarSettingTab(this.app, this));
    this.app.workspace.trigger("parse-style-settings");
    debugLog("LOADED");
    this.app.workspace.onLayoutReady(() => {
      debugLog("onload: rendering initial toolbar");
      this.renderToolbarForActiveFile();
    });
  }
  /**
   * When this plugin is unloaded (e.g., disabled in settings, or Obsidian is restarted):
   * removes all toolbars.
   */
  async onunload() {
    this.removeAllToolbars();
    debugLog("UNLOADED");
  }
  /*************************************************************************
   * TOOLBAR RENDERERS
   *************************************************************************/
  /**
   * Checks if the provided file and frontmatter meets the criteria to render a toolbar,
   * or if we need to remove the toolbar if it shouldn't be there.
   * @param file TFile (note) to check if we need to create a toolbar.
   * @param frontmatter FrontMatterCache to check if there's a prop for the toolbar.
   */
  async checkAndRenderToolbar(file, frontmatter) {
    debugLog("checkAndRenderToolbar()");
    let matchingToolbar = this.getMatchingToolbar(frontmatter, file);
    let toolbarRemoved = this.removeToolbarIfNeeded(matchingToolbar);
    if (matchingToolbar && toolbarRemoved) {
      debugLog("-- RENDERING TOOLBAR: ", matchingToolbar, " for file: ", file);
      this.renderToolbarFromSettings(matchingToolbar);
    }
  }
  /**
   * Get toolbar for the given frontmatter (based on a toolbar prop), and failing that the file (based on folder mappings).
   * @param frontmatter FrontMatterCache to check if there's a prop for the toolbar.
   * @param file The note to check if we have a toolbar for.
   * @returns ToolbarSettings or undefined, if there is no matching toolbar.
   */
  getMatchingToolbar(frontmatter, file) {
    var _a, _b;
    debugLog("getMatchingToolbar()");
    let matchingToolbar = void 0;
    const propName = this.settings.toolbarProp;
    const notetoolbarProp = (_a = frontmatter == null ? void 0 : frontmatter[propName]) != null ? _a : null;
    if (notetoolbarProp !== null) {
      matchingToolbar = this.getToolbarSettingsFromProps(notetoolbarProp);
    }
    if (!matchingToolbar) {
      let mapping;
      let filePath;
      for (let index = 0; index < this.settings.folderMappings.length; index++) {
        mapping = this.settings.folderMappings[index];
        filePath = ((_b = file.parent) == null ? void 0 : _b.path) === "/" ? "/" : file.path.toLowerCase();
        if (["*"].includes(mapping.folder) || filePath.toLowerCase().startsWith(mapping.folder.toLowerCase())) {
          matchingToolbar = this.getToolbarSettings(mapping.toolbar);
          if (matchingToolbar) {
            break;
          }
        }
      }
    }
    return matchingToolbar;
  }
  /**
   * Renders the toolbar for the provided toolbar settings.
   * @param toolbar ToolbarSettings
   */
  async renderToolbarFromSettings(toolbar) {
    debugLog("renderToolbarFromSettings: ", toolbar);
    let noteToolbarUl = document.createElement("ul");
    noteToolbarUl.setAttribute("role", "menu");
    toolbar.items.filter((item) => {
      return item.label === "" && item.icon === "" ? false : true;
    }).map((item) => {
      let toolbarItem = document.createElement("a");
      toolbarItem.className = "external-link";
      toolbarItem.setAttribute("href", item.link);
      Object.entries(item.linkAttr).forEach(([key, value]) => {
        toolbarItem.setAttribute(`data-toolbar-link-attr-${key}`, value);
      });
      item.tooltip ? (0, import_obsidian9.setTooltip)(toolbarItem, item.tooltip, { placement: "top" }) : void 0;
      toolbarItem.setAttribute("rel", "noopener");
      toolbarItem.onclick = (e) => this.toolbarClickHandler(e);
      if (item.label) {
        if (item.icon) {
          let itemIcon = toolbarItem.createSpan();
          (0, import_obsidian9.setIcon)(itemIcon, item.icon);
          let itemLabel = toolbarItem.createSpan();
          itemLabel.innerText = item.label;
        } else {
          toolbarItem.innerText = item.label;
        }
      } else {
        (0, import_obsidian9.setIcon)(toolbarItem, item.icon);
      }
      let noteToolbarLi = document.createElement("li");
      const [hideOnDesktop, hideOnMobile] = calcItemVisToggles(item.contexts[0].platform);
      hideOnMobile ? noteToolbarLi.addClass("hide-on-mobile") : false;
      hideOnDesktop ? noteToolbarLi.addClass("hide-on-desktop") : false;
      noteToolbarLi.append(toolbarItem);
      noteToolbarUl.appendChild(noteToolbarLi);
    });
    let noteToolbarCalloutContent = document.createElement("div");
    noteToolbarCalloutContent.className = "callout-content";
    noteToolbarCalloutContent.append(noteToolbarUl);
    let noteToolbarCallout = document.createElement("div");
    noteToolbarCallout.className = "callout cg-note-toolbar-callout";
    noteToolbarCallout.setAttribute("data-callout", "note-toolbar");
    noteToolbarCallout.setAttribute("data-callout-metadata", [...toolbar.defaultStyles, ...toolbar.mobileStyles].join("-"));
    noteToolbarCallout.append(noteToolbarCalloutContent);
    let div = document.createElement("div");
    div.append(noteToolbarCallout);
    let embedBlock = document.createElement("div");
    embedBlock.className = "cm-embed-block cm-callout cg-note-toolbar-container";
    embedBlock.setAttribute("data-name", toolbar.name);
    embedBlock.setAttribute("data-updated", toolbar.updated);
    embedBlock.oncontextmenu = (e) => this.toolbarContextMenuHandler(e);
    embedBlock.append(div);
    this.registerDomEvent(embedBlock, "keydown", (e) => this.toolbarKeyboardHandler(e));
    switch (toolbar.positions[0].position) {
      case "top":
        embedBlock.addClass("cg-note-toolbar-position-top");
        let currentView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
        let viewHeader = currentView == null ? void 0 : currentView.containerEl.querySelector(".view-header");
        viewHeader ? viewHeader.insertAdjacentElement("afterend", embedBlock) : debugLog("\u{1F6D1} renderToolbarFromSettings: Unable to find .view-header to insert toolbar");
        break;
      case "props":
      default:
        let propsEl = this.getPropsEl();
        if (!propsEl) {
          debugLog("\u{1F6D1} renderToolbarFromSettings: Unable to find .metadata-container to insert toolbar");
        }
        propsEl == null ? void 0 : propsEl.insertAdjacentElement("afterend", embedBlock);
        break;
    }
  }
  /**
   * Creates the toolbar in the active file (assuming it needs one).
   */
  async renderToolbarForActiveFile() {
    var _a;
    let activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      let frontmatter = activeFile ? (_a = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter : void 0;
      this.checkAndRenderToolbar(activeFile, frontmatter);
    }
  }
  /*************************************************************************
   * COMMANDS
   *************************************************************************/
  /**
   * Sets the focus on the first item in the toolbar.
   */
  async focusCommand() {
    debugLog("focusCommand()");
    let itemsUl = this.getToolbarListEl();
    if (itemsUl) {
      debugLog("focus command: toolbar: ", itemsUl);
      let items = Array.from(itemsUl.children);
      const visibleItems = items.filter((item) => {
        return window.getComputedStyle(item).getPropertyValue("display") !== "none";
      });
      const link = visibleItems[0] ? visibleItems[0].querySelector("a") : null;
      debugLog("focus command: focussed item: ", link);
      link == null ? void 0 : link.focus();
    }
  }
  /**
   * Convenience command to open Note Toolbar's settings.
   */
  async openSettingsCommand() {
    const settings = this.app.setting;
    settings.open();
    settings.openTabById("note-toolbar");
  }
  /**
   * Shows, completely hides, or toggles the visibility of this note's Properties.
   * @param visibility Set to 'show', 'hide', or 'toggle'
   */
  async togglePropsCommand(visibility) {
    let propsEl = this.getPropsEl();
    let currentView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
    debugLog("togglePropsCommand: ", "visibility: ", visibility, "props: ", propsEl);
    if (propsEl && !currentView.editMode.sourceMode) {
      let propsDisplayStyle = getComputedStyle(propsEl).getPropertyValue("display");
      visibility === "toggle" ? propsDisplayStyle === "none" ? visibility = "show" : visibility = "hide" : void 0;
      switch (visibility) {
        case "show":
          propsEl.style.display = "var(--metadata-display-editing)";
          if (propsEl.classList.contains("is-collapsed")) {
            propsEl.querySelector(".metadata-properties-heading").click();
          }
          break;
        case "hide":
          propsEl.style.display = "none";
          break;
      }
    }
  }
  /*************************************************************************
   * HANDLERS
   *************************************************************************/
  /**
   * Handles keyboard navigation within the toolbar.
   * @param e KeyboardEvent
   */
  async toolbarKeyboardHandler(e) {
    var _a, _b, _c;
    debugLog("toolbarKeyboardHandler: ", e);
    let itemsUl = this.getToolbarListEl();
    if (itemsUl) {
      e.key ? ["ArrowRight", "ArrowDown", "ArrowLeft", "ArrowUp", " "].includes(e.key) ? e.preventDefault() : void 0 : void 0;
      let items = Array.from(itemsUl.children);
      const visibleItems = items.filter((item) => {
        return window.getComputedStyle(item).getPropertyValue("display") !== "none";
      });
      let currentIndex = visibleItems.indexOf((_a = document.activeElement) == null ? void 0 : _a.parentElement);
      switch (e.key) {
        case "ArrowRight":
        case "ArrowDown":
          const nextIndex = (currentIndex + 1) % visibleItems.length;
          (_b = visibleItems[nextIndex].querySelector("a")) == null ? void 0 : _b.focus();
          break;
        case "ArrowLeft":
        case "ArrowUp":
          const prevIndex = (currentIndex - 1 + visibleItems.length) % visibleItems.length;
          (_c = visibleItems[prevIndex].querySelector("a")) == null ? void 0 : _c.focus();
          break;
        case " ":
          (document == null ? void 0 : document.activeElement).click();
          break;
        case "Escape":
          let currentView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
          let viewMode = currentView == null ? void 0 : currentView.getMode();
          if (viewMode === "preview") {
            (document == null ? void 0 : document.activeElement).blur();
          }
          break;
      }
    }
  }
  /**
   * On click of an item in the toolbar, we replace any variables that might
   * be in the URL, and then open it.
   * @param e MouseEvent
   */
  async toolbarClickHandler(e) {
    var _a, _b, _c, _d;
    let clickedEl = e.currentTarget;
    let url = clickedEl.getAttribute("href");
    if (url != null) {
      let linkType = clickedEl.getAttribute("data-toolbar-link-attr-type");
      linkType ? ["command", "file", "uri"].includes(linkType) ? e.preventDefault() : void 0 : void 0;
      debugLog("toolbarClickHandler: ", e, "clickedEl: ", clickedEl);
      let linkHasVars = clickedEl.getAttribute("data-toolbar-link-attr-hasVars") ? clickedEl.getAttribute("data-toolbar-link-attr-hasVars") === "true" : true;
      if (linkHasVars) {
        let activeFile = this.app.workspace.getActiveFile();
        url = this.replaceVars(url, activeFile, linkType === "uri");
        debugLog("- url vars replaced: ", url);
      }
      if ((e == null ? void 0 : e.pointerType) === "mouse") {
        clickedEl.blur();
      }
      switch (linkType) {
        case "command":
          let linkCommandId = clickedEl.getAttribute("data-toolbar-link-attr-commandid");
          debugLog("- executeCommandById: ", linkCommandId);
          linkCommandId ? this.app.commands.executeCommandById(linkCommandId) : void 0;
          break;
        case "file":
          let activeFile = (_b = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) != null ? _b : "";
          debugLog("- openLinkText: ", url, " from: ", activeFile);
          this.app.workspace.openLinkText(url, activeFile);
          break;
        case "uri":
          if (isValidUri(url)) {
            window.open(url, "_blank");
          } else {
            let activeFile2 = (_d = (_c = this.app.workspace.getActiveFile()) == null ? void 0 : _c.path) != null ? _d : "";
            this.app.workspace.openLinkText(url, activeFile2);
          }
          break;
      }
      if (false) {
        if (url.toLowerCase().startsWith("onclick:")) {
          let functionName = url.slice(8);
          if (typeof window[functionName] === "function") {
            window[functionName]();
          }
        }
      }
    }
  }
  /**
   * Shows a context menu with links to settings/configuration.
   * @param e MouseEvent
   */
  async toolbarContextMenuHandler(e) {
    e.preventDefault();
    let toolbarEl = e.target.closest(".cg-note-toolbar-container");
    let toolbarName = toolbarEl == null ? void 0 : toolbarEl.getAttribute("data-name");
    let toolbarSettings = toolbarName ? this.getToolbarSettings(toolbarName) : void 0;
    let contextMenu = new import_obsidian9.Menu();
    if (toolbarSettings !== void 0) {
      contextMenu.addItem((item) => {
        item.setTitle("Edit " + toolbarName + "...").setIcon("lucide-pen-box").onClick((menuEvent) => {
          const modal = new ToolbarSettingsModal(this.app, this, null, toolbarSettings);
          modal.setTitle("Edit Toolbar: " + toolbarName);
          modal.open();
        });
      });
    }
    contextMenu.addItem((item) => {
      item.setTitle("Note Toolbar settings...").setIcon("lucide-wrench").onClick((menuEvent) => {
        this.openSettingsCommand();
      });
    });
    contextMenu.showAtPosition(e);
  }
  /**
   * Replace variables in the given string of the format {{variablename}}, with metadata from the file.
   * @param s String to replace the variables in.
   * @param file File with the metadata (name, frontmatter) we'll use to fill in the variables.
   * @param encode True if we should encode the variables (recommended if part of external URL).
   * @returns String with the variables replaced.
   */
  replaceVars(s, file, encode) {
    var _a;
    let noteTitle = file == null ? void 0 : file.basename;
    if (noteTitle != null) {
      s = s.replace("{{note_title}}", encode ? encodeURIComponent(noteTitle) : noteTitle);
    }
    let frontmatter = file ? (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter : void 0;
    if (frontmatter) {
      s = s.replace(/{{prop_(.*?)}}/g, (match, p1) => {
        const key = p1.trim();
        if (frontmatter && frontmatter[key] !== void 0) {
          let fm = Array.isArray(frontmatter[key]) ? frontmatter[key].join(",") : frontmatter[key];
          const linkWrap = /\[\[|\]\]/g;
          return encode ? encodeURIComponent(fm.replace(linkWrap, "")) : fm.replace(linkWrap, "");
        } else {
          return "";
        }
      });
    }
    return s;
  }
  /*************************************************************************
   * ELEMENT GETTERS
   *************************************************************************/
  /**
   * Gets the Properties container in the current view.
   * @returns HTMLElement or null, if it doesn't exist.
   */
  getPropsEl() {
    let currentView = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView);
    let propertiesContainer = document.querySelector(".workspace-leaf.mod-active .markdown-" + (currentView == null ? void 0 : currentView.getMode()) + "-view .metadata-container");
    debugLog("getPropsEl: ", ".workspace-leaf.mod-active .markdown-" + (currentView == null ? void 0 : currentView.getMode()) + "-view .metadata-container");
    return propertiesContainer;
  }
  /**
   * Get the toolbar element, in the current view.
   * @param positionsToCheck 
   * @returns HTMLElement or null, if it doesn't exist.
   */
  getToolbarEl() {
    let existingToolbarEl = document.querySelector(".workspace-leaf.mod-active .cg-note-toolbar-container");
    debugLog("getToolbarEl: ", existingToolbarEl);
    return existingToolbarEl;
  }
  /**
   * Get the toolbar element's <ul> element, in the current view.
   * @returns HTMLElement or null, if it doesn't exist.
   */
  getToolbarListEl() {
    let itemsUl = document.querySelector(".workspace-leaf.mod-active .cg-note-toolbar-container .callout-content > ul");
    return itemsUl;
  }
  /*************************************************************************
   * TOOLBAR REMOVAL
   *************************************************************************/
  /**
   * Remove the toolbar on the active file.
   */
  async removeActiveToolbar() {
    let existingToolbar = document.querySelector(".workspace-leaf.mod-active .cg-note-toolbar-container");
    existingToolbar == null ? void 0 : existingToolbar.remove();
  }
  /**
   * Remove any toolbars in all open files.
   */
  async removeAllToolbars() {
    let existingToolbars = document.querySelectorAll(".cg-note-toolbar-container");
    existingToolbars.forEach((toolbar) => {
      toolbar.remove();
    });
  }
  /**
   * Removes toolbar in the current view only if needed: there is no valid toolbar to check against; 
   * the toolbar names don't match; it's out of date with the settings; or it's not in the correct DOM position. 
   * @param correctToolbar ToolbarSettings for the toolbar that should be used.
   * @returns true if the toolbar was removed (or doesn't exist), false otherwise.
   */
  removeToolbarIfNeeded(correctToolbar) {
    let toolbarRemoved = false;
    let existingToolbarEl = this.getToolbarEl();
    debugLog("removeToolbarIfNeeded: correct: ", correctToolbar, "existing: ", existingToolbarEl);
    if (existingToolbarEl) {
      let existingToolbarName = existingToolbarEl == null ? void 0 : existingToolbarEl.getAttribute("data-name");
      let existingToolbarUpdated = existingToolbarEl.getAttribute("data-updated");
      let existingToolbarHasSibling = existingToolbarEl.nextElementSibling;
      if (!correctToolbar) {
        debugLog("- toolbar not needed, removing existing toolbar: " + existingToolbarName);
        toolbarRemoved = true;
      } else if (correctToolbar.name !== existingToolbarName) {
        debugLog("- toolbar needed, removing existing toolbar (name does not match): " + existingToolbarName);
        toolbarRemoved = true;
      } else if (correctToolbar.updated !== existingToolbarUpdated) {
        debugLog("- existing toolbar out of date, removing existing toolbar");
        toolbarRemoved = true;
      } else if (existingToolbarHasSibling == null ? void 0 : existingToolbarHasSibling.hasClass("inline-title")) {
        debugLog("- not in the correct position (sibling is `inline-title`), removing existing toolbar");
        toolbarRemoved = true;
      }
      if (toolbarRemoved) {
        existingToolbarEl.remove();
        existingToolbarEl = null;
      }
    } else {
      debugLog("- no existing toolbar");
      toolbarRemoved = true;
    }
    if (!toolbarRemoved) {
      debugLog("removeToolbarIfNeeded: nothing done");
    }
    return toolbarRemoved;
  }
  /*************************************************************************
   * SETTINGS LOADERS
   *************************************************************************/
  /**
   * Loads settings, and migrates from old versions if needed.
   * 
   * 1. Update SETTINGS_VERSION in NoteToolbarSettings.
   * 2. Add MIGRATION block below.
   * 
   * Credit to Fevol on Discord for the sample code to migrate.
   * @link https://discord.com/channels/686053708261228577/840286264964022302/1213507979782127707
   */
  async loadSettings() {
    var _a, _b, _c, _d;
    const loaded_settings = await this.loadData();
    debugLog("loadSettings: loaded settings: ", loaded_settings);
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loaded_settings);
    let old_version = loaded_settings == null ? void 0 : loaded_settings.version;
    let new_version;
    if (loaded_settings && old_version !== SETTINGS_VERSION) {
      debugLog("loadSettings: versions do not match: data.json: ", old_version, " !== latest: ", SETTINGS_VERSION);
      debugLog("running migrations...");
      if (!old_version) {
        new_version = 202403181e-1;
        debugLog("- starting migration: " + old_version + " -> " + new_version);
        (_a = loaded_settings.toolbars) == null ? void 0 : _a.forEach((tb, index) => {
          if (tb.styles) {
            debugLog("	- OLD SETTING: " + tb.styles);
            debugLog("		- SETTING: this.settings.toolbars[index].defaultStyles: " + this.settings.toolbars[index].defaultStyles);
            this.settings.toolbars[index].defaultStyles = tb.styles;
            debugLog("		- SET: " + this.settings.toolbars[index].defaultStyles);
            debugLog("		- SETTING: this.settings.toolbars[index].mobileStyles = []");
            this.settings.toolbars[index].mobileStyles = [];
            delete tb.styles;
          }
        });
        old_version = new_version;
      }
      if (old_version === 202403181e-1) {
        new_version = 202403221e-1;
        debugLog("- starting migration: " + old_version + " -> " + new_version);
        (_b = loaded_settings.toolbars) == null ? void 0 : _b.forEach((tb, index) => {
          tb.items.forEach((item, item_index) => {
            if (!(item == null ? void 0 : item.urlAttr)) {
              debugLog("  - add urlAttr for: ", tb.name, item.label);
              item.urlAttr = {
                hasVars: true,
                isUri: true
              };
            }
          });
        });
        old_version = new_version;
      }
      if (old_version === 202403221e-1) {
        new_version = 202403301e-1;
        debugLog("- starting migration: " + old_version + " -> " + new_version);
        (_c = loaded_settings.toolbars) == null ? void 0 : _c.forEach((tb, index) => {
          tb.items.forEach((item, item_index) => {
            this.settings.toolbars[index].items[item_index].icon = "";
            if (item.url) {
              this.settings.toolbars[index].items[item_index].link = item.url;
              delete item.url;
            }
            if (item.urlAttr) {
              this.settings.toolbars[index].items[item_index].linkAttr = {
                commandId: "",
                hasVars: item.urlAttr.hasVars,
                type: item.urlAttr.isUri ? "uri" : "file"
              };
              delete item.urlAttr;
            }
          });
        });
        old_version = new_version;
      }
      if (old_version === 202403301e-1) {
        new_version = 202404161e-1;
        debugLog("- starting migration: " + old_version + " -> " + new_version);
        (_d = loaded_settings.toolbars) == null ? void 0 : _d.forEach((tb, index) => {
          tb.items.forEach((item, item_index) => {
            this.settings.toolbars[index].items[item_index].contexts = [{
              platform: calcItemVisPlatform(item.hideOnDesktop, item.hideOnMobile),
              view: "all"
            }];
            delete item.hideOnDesktop;
            delete item.hideOnMobile;
          });
          this.settings.toolbars[index].positions = [{
            position: "props",
            contexts: [{
              platform: "all",
              view: "all"
            }]
          }];
        });
        old_version = new_version;
      }
      this.settings.version = SETTINGS_VERSION;
      debugLog("updated settings:", this.settings);
      await this.saveSettings();
    }
  }
  /**
   * Saves settings.
   * Sorts the toolbar list (by name) first.
   */
  async saveSettings() {
    await this.saveData(this.settings);
    await this.removeActiveToolbar();
    await this.renderToolbarForActiveFile();
    debugLog("SETTINGS SAVED: " + new Date().getTime());
  }
  /**
   * Loads settings if the data file is changed externally (e.g., by Obsidian Sync).
   */
  async onExternalSettingsChange() {
    debugLog("onExternalSettingsChange()");
  }
  /**
   * Gets toolbar from settings, using the provided name.
   * @param name Name of toolbar to get settings for (case-insensitive).
   * @returns ToolbarSettings for the provided matched toolbar name, undefined otherwise.
   */
  getToolbarSettings(name) {
    return name ? this.settings.toolbars.find((tbar) => tbar.name.toLowerCase() === name.toLowerCase()) : void 0;
  }
  /**
   * Gets toolbar from settings, using the provided array of strings (which will come from note frontmatter).
   * @param names List of potential toolbars to get settings for (case-insensitive); only the first match is returned.
   * @returns ToolbarSettings for the provided matched toolbar name, undefined otherwise.
   */
  getToolbarSettingsFromProps(names) {
    if (!names)
      return void 0;
    if (typeof names === "string") {
      return this.getToolbarSettings(names);
    }
    return this.settings.toolbars.find((tbar) => names.some((name) => tbar.name.toLowerCase() === name.toLowerCase()));
  }
  /**
   * Removes the provided toolbar from settings; does nothing if it does not exist.
   * @param name Name of the toolbar to remove.
   */
  deleteToolbarFromSettings(name) {
    this.settings.toolbars = this.settings.toolbars.filter((tbar) => tbar.name !== name);
  }
};
