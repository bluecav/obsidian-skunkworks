/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  PopoverSelectString: () => PopoverSelectString,
  askSelectString: () => askSelectString,
  default: () => ScrewDriverPlugin
});
var import_obsidian = __toModule(require("obsidian"));
function getFiles(app, path, ignoreList, filter) {
  return __async(this, null, function* () {
    const w = yield app.vault.adapter.list(path);
    let files = [
      ...w.files.filter((e) => !ignoreList.some((ee) => e.endsWith(ee))).filter((e) => !filter || filter.some((ee) => e.match(ee)))
    ];
    L1:
      for (const v of w.folders) {
        for (const ignore of ignoreList) {
          if (v.endsWith(ignore)) {
            continue L1;
          }
        }
        files = files.concat(yield getFiles(app, v, ignoreList, filter));
      }
    return files;
  });
}
function getDirectories(app, path, ignoreList) {
  return __async(this, null, function* () {
    const w = yield app.vault.adapter.list(path);
    let dirs = [];
    L1:
      for (const v of w.folders) {
        for (const ignore of ignoreList) {
          if (v.endsWith(ignore)) {
            continue L1;
          }
        }
        dirs = dirs.concat([v]);
        dirs = dirs.concat(yield getDirectories(app, v, ignoreList));
      }
    return dirs;
  });
}
function isPlainText(filename) {
  if (filename.endsWith(".md"))
    return true;
  if (filename.endsWith(".txt"))
    return true;
  if (filename.endsWith(".svg"))
    return true;
  if (filename.endsWith(".html"))
    return true;
  if (filename.endsWith(".csv"))
    return true;
  if (filename.endsWith(".css"))
    return true;
  if (filename.endsWith(".js"))
    return true;
  if (filename.endsWith(".json"))
    return true;
  if (filename.endsWith(".xml"))
    return true;
  if (filename.endsWith(".ts"))
    return true;
  if (filename.endsWith(".canvas"))
    return true;
  return false;
}
function ensureDirectory(app, fullpath) {
  return __async(this, null, function* () {
    const pathElements = fullpath.split("/");
    pathElements.pop();
    let c = "";
    for (const v of pathElements) {
      c += v;
      try {
        yield app.vault.createFolder(c);
      } catch (ex) {
        if (ex.message && ex.message == "Folder already exists.") {
        } else {
          new import_obsidian.Notice("Folder Create Error");
          console.log(ex);
        }
      }
      c += "/";
    }
  });
}
var ScrewDriverPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addCommand({
        id: "screwdriver-add-target-dir",
        name: "Add target directory",
        editorCallback: (editor, view) => __async(this, null, function* () {
          const list = yield getDirectories(this.app, this.app.vault.configDir, ["node_modules", ".git"]);
          const selected = yield askSelectString(this.app, "Select target directory", list);
          if (selected) {
            let filters = [];
            if (selected.indexOf("plugins") !== -1) {
              if ((yield askSelectString(this.app, "Do you want to include plugin's data?", ["yes", "no"])) == "yes") {
                filters = ["main\\.js$", "manifest\\.json$", "styles\\.css$", "data\\.json$"];
              } else {
                filters = ["main\\.js$", "manifest\\.json$", "styles\\.css$"];
              }
            } else if (selected.indexOf("themes") !== -1) {
              filters = ["manifest\\.json$", "theme\\.css$"];
            } else if (selected.indexOf("snippets") !== -1) {
              filters = (yield getFiles(this.app, selected, [], [/\.css$/])).map((e) => e.substring(selected.length).replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "$");
            }
            this.app.fileManager.processFrontMatter(view.file, (fm) => __async(this, null, function* () {
              var _a, _b;
              fm.targets = [...new Set([...(_a = fm.targets) != null ? _a : [], selected])];
              if (filters.length > 0) {
                fm.filters = [...new Set([...(_b = fm.filters) != null ? _b : [], ...filters])];
              }
            }));
          }
        })
      });
      this.addCommand({
        id: "screwdriver-create-template-dump",
        name: "Create or add local file exporting template",
        editorCallback: (editor, view) => __async(this, null, function* () {
          this.app.fileManager.processFrontMatter(view.file, (fn) => {
            var _a, _b, _c, _d, _e;
            fn.targets = (_a = fn.targets) != null ? _a : [];
            fn.ignores = (_b = fn.ignores) != null ? _b : ["/node_modules", "/.git"];
            fn.filters = (_c = fn.filters) != null ? _c : [];
            fn.comment = (_d = fn.comment) != null ? _d : "'Add target directory' to add targets";
            fn.tags = (_e = fn.tags) != null ? _e : [];
          });
        })
      });
      this.addCommand({
        id: "screwdriver-create-template-fetch",
        name: "Create or add remote file fetching template",
        editorCallback: (editor, view) => __async(this, null, function* () {
          this.app.fileManager.processFrontMatter(view.file, (fn) => {
            var _a, _b, _c, _d;
            fn.urls = (_a = fn.urls) != null ? _a : [];
            fn.authorization = (_b = fn.authorization) != null ? _b : "";
            fn.tags = (_c = fn.tags) != null ? _c : [];
            fn.header_json = (_d = fn.header_json) != null ? _d : "";
          });
        })
      });
      this.addCommand({
        id: "screwdriver-dump",
        name: "Export specified files and store into the active file",
        editorCallback: (editor, view) => __async(this, null, function* () {
          var _a, _b, _c;
          const data = view.data;
          const bodyStartIndex = data.indexOf("\n---");
          if (!data.startsWith("---") || bodyStartIndex === -1) {
            new import_obsidian.Notice("Frontmatter was not found.");
          }
          const yaml = data.substring(3, bodyStartIndex);
          const yamlData = (0, import_obsidian.parseYaml)(yaml);
          let newData = "---" + yaml + "\n---\n\n";
          const target = (_a = yamlData.target) != null ? _a : "";
          let targets = (_b = yamlData.targets) != null ? _b : [];
          if (target)
            targets = [...targets, target];
          targets = targets.map((e) => e.trim()).filter((e) => e != "");
          const ignoresSrc = yamlData.ignores;
          const ignores = Array.isArray(ignoresSrc) ? ignoresSrc : (ignoresSrc + "").split(",");
          const filterSrc = yamlData.filters;
          const filters = !filterSrc ? null : filterSrc.map((e) => new RegExp(e));
          const urls = (_c = yamlData.urls) != null ? _c : "";
          if (targets.length == 0 && urls == "") {
            new import_obsidian.Notice("Target folders or urls are not specified.");
            return;
          }
          for (const url of urls) {
            try {
              let fileDat = "";
              let bin = false;
              const w = yield (0, import_obsidian.requestUrl)(url);
              const filename = new URL(url).pathname.split("/").last();
              const dt = w.arrayBuffer;
              try {
                const text = new TextDecoder("utf-8", { fatal: true }).decode(dt);
                fileDat = text;
                fileDat = fileDat.replace(/\\/g, "\\\\");
                fileDat = fileDat.replace(/`/g, "\\`");
              } catch (ex2) {
                fileDat = yield (0, import_obsidian.arrayBufferToBase64)(dt);
                bin = true;
              }
              newData += "\n";
              newData += `# ${url} 
`;
              newData += `- Fetched :${new Date().toLocaleString()} 
`;
              newData += "\n```screwdriver:" + filename + (bin ? ":bin" : "") + "\n";
              newData += fileDat + "";
              newData += "\n```";
            } catch (ex) {
              new import_obsidian.Notice(`Error on fetching ${url}
${ex}`);
            }
          }
          for (const target2 of targets) {
            const files = yield getFiles(this.app, target2, ignores, filters);
            for (const file of files) {
              let fileDat = "";
              let bin = false;
              const dt = yield this.app.vault.adapter.readBinary(file);
              const stat = yield this.app.vault.adapter.stat(file);
              try {
                const text = new TextDecoder("utf-8", { fatal: true }).decode(dt);
                fileDat = text;
                fileDat = fileDat.replace(/\\/g, "\\\\");
                fileDat = fileDat.replace(/`/g, "\\`");
              } catch (ex2) {
                fileDat = yield (0, import_obsidian.arrayBufferToBase64)(dt);
                bin = true;
              }
              newData += "\n";
              newData += `# ${file} 
`;
              newData += `- Created :${new Date(stat.ctime).toLocaleString()} 
`;
              newData += `- Modified:${new Date(stat.mtime).toLocaleString()} 
`;
              newData += "\n```screwdriver:" + file + ":" + (bin ? "bin" : "plain") + "\n";
              newData += fileDat + "";
              newData += "\n```";
            }
          }
          editor.setValue(newData);
        })
      });
      this.registerMarkdownCodeBlockProcessor("screwdriver", (source, el, ctx) => {
        const sourcePath = ctx.sourcePath;
        const si = ctx.getSectionInfo(el);
        const fxx = si.text.split("\n")[si.lineStart];
        const filename = `${fxx}:::`.split(":")[1];
        const rSource = `${"```\n"}${source}${"\n```"}`;
        const renderSource = `> [!screwdriver]- ${filename}
${rSource.replace(/^/mg, "> ")}`;
        const fx = el.createDiv({ text: "", cls: ["screwdriver-display"] });
        import_obsidian.MarkdownRenderer.renderMarkdown(renderSource, fx, sourcePath, this);
        el.replaceWith(fx);
      });
      this.addCommand({
        id: "screwdriver-restore",
        name: "Restore exported files from the active file",
        editorCallback: (editor, view) => __async(this, null, function* () {
          const data = view.data;
          if (data.startsWith("---")) {
            const bodyStartIndex = data.indexOf("\n---");
            if (bodyStartIndex !== -1) {
              const preBlocks = data.substring(bodyStartIndex).matchAll(/^```(?:screwdriver:|)([\s\S]*?)\n([\s\S]*?)^```/gm);
              for (const preBlock of preBlocks) {
                const [, filenameSrc, data2] = preBlock;
                const [filename, dataType] = `${filenameSrc}:`.split(":");
                let saveData = data2;
                try {
                  if (isPlainText(filename) && dataType != "bin" || dataType == "plain") {
                    saveData = saveData.replace(/\\`/g, "`");
                    saveData = saveData.replace(/\\\\/g, "\\");
                    saveData = saveData.substring(0, saveData.lastIndexOf("\n"));
                    yield ensureDirectory(this.app, filename);
                    yield this.app.vault.adapter.write(filename, saveData);
                  } else {
                    saveData = saveData.substring(0, saveData.lastIndexOf("\n"));
                    const saveDataArrayBuffer = (0, import_obsidian.base64ToArrayBuffer)(saveData);
                    yield ensureDirectory(this.app, filename);
                    yield this.app.vault.adapter.writeBinary(filename, saveDataArrayBuffer);
                  }
                  new import_obsidian.Notice(`File:${filename} has been wrote to your device.`);
                  console.log(`File:${filename} has been wrote to your device.`);
                } catch (ex) {
                  new import_obsidian.Notice(`Failed to write ${filename}`);
                  console.error(`Failed to write ${filename}`);
                  console.log(ex);
                }
              }
              return;
            }
          }
          new import_obsidian.Notice("Frontmatter was not found.");
          console.error("Frontmatter was not found");
        })
      });
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
    });
  }
};
var PopoverSelectString = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, note, placeholder, getItemsFun, callback) {
    super(app);
    this.callback = () => {
    };
    this.getItemsFun = () => {
      return ["yes", "no"];
    };
    this.app = app;
    this.setPlaceholder((placeholder != null ? placeholder : "y/n) ") + note);
    if (getItemsFun)
      this.getItemsFun = getItemsFun;
    this.callback = callback;
  }
  getItems() {
    return this.getItemsFun();
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    this.callback(item);
    this.callback = null;
  }
  onClose() {
    setTimeout(() => {
      if (this.callback != null) {
        this.callback("");
      }
    }, 100);
  }
};
var askSelectString = (app, message, items) => {
  const getItemsFun = () => items;
  return new Promise((res) => {
    const popover = new PopoverSelectString(app, message, "", getItemsFun, (result) => res(result));
    popover.open();
  });
};
